using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows;
using System.Windows.Media;
using Framework.Utilities.Util;

namespace SwiftERP.Framework.Utilities.Extensions
{
    /// <summary>
    /// Extension Methods for the String Class.
    /// </summary>
    public static class StringExtensions
    {
        /// <summary>
        /// Index of Nth ocurrence of the specified string (value), starting at startIndex.
        /// </summary>
        /// <param name="input">Source string</param>
        /// <param name="value">Value to find the Nth Index Of in input</param>
        /// <param name="startIndex">Index to begin the search</param>
        /// <param name="nth">Nth desired Index Of</param>
        /// <returns>Nth Index Of of the specified string in the input string
        /// starting at the specified index.</returns>
        public static int IndexOfNth(this string input, string value, int startIndex, int nth)
        {
            if (nth < 1)
            {
                throw new NotSupportedException("Param 'nth' must be greater than 0!");
            }

            if (nth == 1)
            {
                return input.IndexOf(value, startIndex, StringComparison.Ordinal);
            }

            var idx = input.IndexOf(value, startIndex, StringComparison.Ordinal);

            if (idx < 0)
            {
                return -1;
            }

            return input.IndexOfNth(value, idx + 1, --nth);
        }

        /// <summary>
        /// Converts a string to decimal.
        /// If the string begin with parenthesis, the parenthesis will be
        /// considered as the negative sign of the decimal number.
        /// </summary>
        /// <param name="convString">String to convert to decimal.</param>
        /// <returns>Decimal obtained from the specified string</returns>
        public static decimal ConvertToDecimal(this string convString)
        {
            decimal result = 0;
            decimal convResult;

            if (convString != null && convString.Contains("(") && convString.Length >= 3)
            {
                convString = "-" + convString.Substring(1, convString.Length - 2);
            }

			var tuple = convString.RemoveSpecialCharactersFromDecimal();

			if(tuple.Item1)
			{
				return 0;
			}

			var decimalString = tuple.Item2;

			if (decimal.TryParse(decimalString, out convResult))
            {
                result = convResult;
            }

            return result;
        }

        /// <summary>
        /// Converts a string to double.
        /// If the string begin with parenthesis, the parenthesis will be
        /// considered as the negative sign of the double number.
        /// </summary>
        /// <param name="convString">String to convert to double.</param>
        /// <returns>Double obtained from the specified string</returns>
        public static double ConvertToDouble(this string convString)
        {
            double result = 0;
            double convResult;

            if (convString != null && convString.Contains("(") && convString.Length >= 3)
            {
                convString = "-" + convString.Substring(1, convString.Length - 2);
            }

            var tuple = convString.RemoveSpecialCharactersFromDecimal();

            if (tuple.Item1)
            {
                return 0;
            }

            var doubleString = tuple.Item2;

            if (double.TryParse(doubleString, out convResult))
            {
                result = convResult;
            }

            return result;
        }

        /// <summary>
        /// Replaces the last ocurrence of the find string by the newString in the source string
        /// </summary>
        /// <param name="source">Source string</param>
        /// <param name="find">String to be replaced it's last ocurrence</param>
        /// <param name="newString">String to replace</param>
        /// <returns>String replaced</returns>
        public static string ReplaceLastOccurrence(this string source, string find, string newString)
        {
            var place = source.LastIndexOf(find, StringComparison.Ordinal);

            if (place == -1)
            {
                return source;
            }

            var result = source.Remove(place, find.Length).Insert(place, newString);

            return result;
        }

        public static string Repeat(this string s, int n)
        {
            return new string(Enumerable.Range(0, n).SelectMany(x => s).ToArray());
        }

        public static string Repeat(this char c, int n)
        {
            return new string(c, n);
        }

        /// <summary>
        /// Returns the string with the first char in Upper case and
        /// the rest of the string in Lower Case.
        /// </summary>
        /// <param name="input">String.</param>
        /// <returns>String with the first char in Upper case and
        /// the rest of the string in lower case.</returns>
        public static string FirstCharUpper(this string input, bool restLower = true)
        {
            if (string.IsNullOrWhiteSpace(input))
            {
                return string.Empty;
            }

            var resultString = input[0].ToString().ToUpper();

            if (input.Length > 1)
            {
                if (restLower)
                {
                    resultString += input.Substring(1).ToLower();
                }
                else
                {
                    resultString += input.Substring(1);
                }
            }

            return resultString;
        }

        /// <summary>
        /// Returns the string with the first char in Lower case and
        /// the rest of the string remains the same.
        /// </summary>
        /// <param name="input">String.</param>
        /// <returns>String with the first char in Lower case and
        /// the rest of the string remains the same.</returns>
        public static string FirstCharLower(this string input)
        {
            if (string.IsNullOrWhiteSpace(input))
            {
                return string.Empty;
            }

            var resultString = input[0].ToString().ToLower();

            if (input.Length > 1)
            {
                resultString += input.Substring(1);
            }

            return resultString;
        }

        public static bool Contains(this string source, string toCheck, StringComparison comp)
        {
            return source.IndexOf(toCheck, comp) >= 0;
        }

        public static int ConvertToInt(this string source)
        {
            int result;
            return int.TryParse(source, out result) ? result : -1;
        }

        /// <summary>
        /// Returns the Plural of the String.
        /// </summary>
        /// <param name="text">String to be Pluralized.</param>
        /// <returns>Plural of the String.</returns>
        public static string Pluralize(this string text)
        {
            if (string.IsNullOrEmpty(text))
            {
                return string.Empty;
            }

            var plural = TableNames.Pluralize(text);

            if (!string.IsNullOrEmpty(plural))
            {
                return plural;
            }
            else if (text.EndsWith("y", StringComparison.OrdinalIgnoreCase) &&
                !text.EndsWith("ay", StringComparison.OrdinalIgnoreCase) &&
                !text.EndsWith("ey", StringComparison.OrdinalIgnoreCase) &&
                !text.EndsWith("iy", StringComparison.OrdinalIgnoreCase) &&
                !text.EndsWith("oy", StringComparison.OrdinalIgnoreCase) &&
                !text.EndsWith("uy", StringComparison.OrdinalIgnoreCase))
            {
                return text.Substring(0, text.Length - 1) + "ies";
            }
            else if (text.EndsWith("us", StringComparison.InvariantCultureIgnoreCase))
            {
                // http://en.wikipedia.org/wiki/Plural_form_of_words_ending_in_-us
                return text + "es";
            }
            else if (text.EndsWith("ss", StringComparison.InvariantCultureIgnoreCase))
            {
                return text + "es";
            }
            else if (text.EndsWith("s", StringComparison.InvariantCultureIgnoreCase))
            {
                return text;
            }
            else if (text.EndsWith("x", StringComparison.InvariantCultureIgnoreCase) ||
                text.EndsWith("ch", StringComparison.InvariantCultureIgnoreCase) ||
                text.EndsWith("sh", StringComparison.InvariantCultureIgnoreCase))
            {
                return text + "es";
            }
            else if (text.EndsWith("f", StringComparison.InvariantCultureIgnoreCase) && text.Length > 1)
            {
                return text.Substring(0, text.Length - 1) + "ves";
            }
            else if (text.EndsWith("fe", StringComparison.InvariantCultureIgnoreCase) && text.Length > 2)
            {
                return text.Substring(0, text.Length - 2) + "ves";
            }
            else
            {
                return text + "s";
            }
        }

        /// <summary>
        /// Returns the Singular of the String.
        /// </summary>
        /// <param name="str">String to be singularized.</param>
        /// <returns>Singular of the String.</returns>
        public static string Singularize(this string str)
        {
            return TableNames.Singularize(str);
        }

        public static string RemoveArticles(this string str)
        {
            var result = str.Replace(" de ", " ");
            result = result.Replace(" of ", " ");

            return result;
        }

        /// <summary>
        /// Checks if the specified string is a valid decimal value.
        /// </summary>
        /// <param name="str">String to be checked as decimal.</param>
        /// <returns>TRUE: The string is a valid decimal value.
        /// FALSE: The string is not a valid decimal value.</returns>
        public static bool IsValidDecimal(this string str)
        {
            return RegularExpressionsUtil.StringIsValidDecimal(str);
        }

		/// <summary>
		/// Removes the Special Characters like Currency Symbol and Super Scripts from the specified string.
		/// </summary>
		/// <param name="str"></param>
		/// <returns>Tuple containing a bool that indicates if the string is currently being constructed and 
		/// should be skipped from decimal conversions and the converted string.</returns>
		public static Tuple<bool, string, string> RemoveSpecialCharactersFromDecimal(this string str)
		{
            var suffix = string.Empty;

            if (string.IsNullOrWhiteSpace(str))
			{
				return new Tuple<bool, string, string>(true, str, suffix);
			}

			var currentString = str;

			//If the String ends in a ., maybe we are still editing the decimal String to create a decimal Value.
			//So, return for now.
			if (currentString.EndsWith("."))
			{
				return new Tuple<bool, string, string>(true, str, suffix);
			}

			//Remove Currency Symbol.
			currentString = currentString.Replace("$", "");

			if(string.IsNullOrWhiteSpace(currentString))
			{
				return new Tuple<bool, string, string>(true, str, suffix);
			}

			if (currentString == "-")
			{
				return new Tuple<bool, string, string>(true, str, suffix);
			}

			var formatted = string.Empty;
            var index = currentString.Length - 1;

            //Get the Suffix of the String that is not a Number.
            //For instance, can be the Code of the Currency.
            for(; index >= 0; index--)
            {
                if(!char.IsNumber(currentString[index]))
                {
                    suffix += currentString[index];
                }
                else
                {
                    break;
                }
            }

            if(!string.IsNullOrEmpty(suffix))
            {
                suffix = suffix.ReverseString();
            }

            //Remove spaces.
            //currentString = currentString.Replace(" ", "");

            //Remove Super Scripts.
            for (var i = 0; i <= index && i < currentString.Length; i++)
			{
                var decimalChar = currentString[i];

				var normalChar = GetCharFromSuperScript(decimalChar.ToString());

				if (normalChar != null)
				{
					formatted += normalChar;
				}
				else if(!char.IsLetter(decimalChar))
				{
					formatted += decimalChar;
				}
			}

			return new Tuple<bool, string, string>(false, formatted, suffix);
		}

        /// <summary>
        /// Add commas for every thousand place.
        /// </summary>
        /// <param name="str">String.</param>
        /// <returns>For instance: For 10000 return 10,000</returns>
        public static string AddCommaInThousands(this string str)
        {
            if(string.IsNullOrEmpty(str))
            {
                return str;
            }

            var indexOf = str.IndexOf(".");
            var length = str.Length;

            if (indexOf > 0)
            {
                length = indexOf;
            }

            var temp = string.Empty;
            var counter = 0;

            for (var i = length - 1; i >= 0; i--)
            {
                if (counter > 0 && counter % 3 == 0 && char.IsNumber(str[i]))
                {
                    temp += ",";
                    counter = 0;
                }

                if (char.IsNumber(str[i]) || str[i] == '-')
                {
                    counter++;
                    temp += str[i];
                }
            }

            //Invert temp.
            temp = temp.ReverseString();

            if(indexOf > 0)
            {
                temp += str.Substring(indexOf);
            }

            return temp;
        }

        /// <summary>
        /// Returns a String with the Format $ decimal.decimals and the decimals are displayed
        /// as a Superscript or Power of the integer Part.
        /// </summary>
        /// <param name="decimalString">This string. (Decimal value as a String).</param>
        /// <param name="includeCurrencySymbol">Indicates if the Currency Symbol will 
        /// be included in the result.</param>
		/// <param name="showNegativeSign">If the number have a negative sign, this parameter indicates if
		/// the negative sign will be displayed or not.</param>
		/// <param name="useSuperScript">Indicates if the Decimal places will be displayed as SuperScripts.</param>
		/// <param name="allowStartWithMultipleZeros">Indicates if the string value can start with multiple zeroes.
		/// Like 002</param>
        /// <param name="addCommaInThousands">Indicates if a comma will be added in every thousand place.
        /// For instance: For 10000 return 10,000</param>
        /// <returns>String with the Format $ decimal.decimals and the decimals are displayed
        /// as a Superscript or Power of the integer Part.</returns>
        public static string FormatToPrice(this string decimalString, bool includeCurrencySymbol = true,
            bool showNegativeSign = true, bool useSuperScript = true, bool allowStartWithMultipleZeros = false,
			int decimalPlaces = BaseConstants.DecimalPlacesDefault, bool addCommaInThousands = true)
        {
            //Check if the string have more than one . character.
            var pointsCount = decimalString.Count(x => x == '.');

            if(pointsCount > 1)
            {
                return string.Empty;
            }

            var tuple = decimalString.RemoveSpecialCharactersFromDecimal();

			if(tuple.Item1)
			{
				return decimalString;
			}

			var formatted = tuple.Item2;
            var suffix = tuple.Item3;

			decimal decimalValue;
            var canConvert = decimal.TryParse(formatted, out decimalValue);

            if (!canConvert 
			|| (!allowStartWithMultipleZeros && !string.IsNullOrEmpty(formatted) && formatted.StartsWith("00")))
            {
                return string.Empty;
            }

            if(addCommaInThousands)
            {
                formatted = formatted.AddCommaInThousands();
            }

			//We don't use this, because this always round the decimal value to 2 Decimal Places.
			//And we want to keep all of the decimal places.
			//var formatted = decimalValue.ToString("C", CultureInfo.GetCultureInfo("en-us"));

            if (includeCurrencySymbol)
            {
                if (formatted[0] == '-' && formatted.Length > 3 && !showNegativeSign)
                {
					//Replace the Minus sign by a Parenthesis.
					formatted = "( $ " + formatted.Substring(1) + ")";
                }
				else if(formatted[0] == '-')
				{
					if (formatted[1] == ' ')
					{
						formatted = formatted.Insert(2, "$ ");
					}
					else
					{
						formatted = formatted.Insert(0, "$ ");
					}
				}
                else
                {
                    formatted = "$ " + formatted;
                }
            }

            //Convert Decimal Places to SuperScript.
            var point = formatted.IndexOf('.');

			if(point > 0)
			{
				//If the string have more decimal places, than the specified decimal places, can't convert the value
				//and return an empty string.
				if(formatted.Length - point > decimalPlaces + 1)
				{
                    //Round to the specified number of decimals.
                    decimal decimalNumber = 0;

                    var converted = decimal.TryParse(formatted, out decimalNumber);

                    if (converted)
                    {
                        decimalNumber = Math.Round(decimalNumber, decimalPlaces);
                        formatted = decimalNumber.ToString();
                    }
                    else
                    {
                        formatted = formatted.Substring(0, point + decimalPlaces);
                    }
					//return string.Empty;
				}
			}

            if (point > 0 && useSuperScript)
            {
                var stringBuilder = new StringBuilder(formatted);				

                for (var i = point + 1; i < formatted.Length; i++)
                {
                    stringBuilder = stringBuilder.Remove(i, 1);
                    stringBuilder = stringBuilder.Insert(i, GetSuperScript(formatted[i]));
                }

                formatted = stringBuilder.ToString();
            }

			if (showNegativeSign && formatted[0] == '(')
            {
                formatted = formatted.Replace("(", "");
                formatted = formatted.Replace(")", "");
                formatted = formatted.Insert(1, " ");
                formatted = formatted.Insert(2, "-");

                if (formatted.Length > 3)
                {
                    formatted = formatted.Insert(3, " ");
                }
            }

            if (formatted.EndsWith(")"))
            {
                formatted.Insert(formatted.Length - 1, " ");
            }

            return formatted + suffix;
        }

        public static string GetSuperScript(char number)
        {
            switch (number)
            {
                case '0':
                    return BaseConstants.SuperScriptZero;
                case '1':
                    return BaseConstants.SuperScriptOne;
                case '2':
                    return BaseConstants.SuperScriptTwo;
                case '3':
                    return BaseConstants.SuperScriptThree;
                case '4':
                    return BaseConstants.SuperScriptFour;
                case '5':
                    return BaseConstants.SuperScriptFive;
                case '6':
                    return BaseConstants.SuperScriptSix;
                case '7':
                    return BaseConstants.SuperScriptSeven;
                case '8':
                    return BaseConstants.SuperScriptEight;
                case '9':
                    return BaseConstants.SuperScriptNine;
                default:
                    return null;
            }
        }

		public static char? GetCharFromSuperScript(string number)
		{
			switch (number)
			{
				case BaseConstants.SuperScriptZero:
					return '0';
				case BaseConstants.SuperScriptOne:
					return '1';
				case BaseConstants.SuperScriptTwo:
					return '2';
				case BaseConstants.SuperScriptThree:
					return '3';
				case BaseConstants.SuperScriptFour:
					return '4';
				case BaseConstants.SuperScriptFive:
					return '5';
				case BaseConstants.SuperScriptSix:
					return '6';
				case BaseConstants.SuperScriptSeven:
					return '7';
				case BaseConstants.SuperScriptEight:
					return '8';
				case BaseConstants.SuperScriptNine:
					return '9';
				default:
					return null;
			}
		}

		/// <summary>
		/// Reverses the String.
		/// </summary>
		/// <param name="str">String to be reversed.</param>
		/// <returns>Reversed String.</returns>
		public static string ReverseString(this string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return string.Empty;
            }

            var reverse = string.Empty;

            for (int i = str.Length - 1; i >= 0; i--)
            {
                reverse += str[i];
            }

            return reverse;
        }

        /// <summary>
        /// Compares 2 strings.
        /// </summary>
        /// <param name="str">This string.</param>
        /// <param name="other">Other string to be compared with this.</param>
        /// <returns>0: Strings are Equals.
        /// 1: This string is Less Than the Other string.
        /// 2: The Other string is Less Than this string.</returns>
        public static int Compare(this string str, string other)
        {
            if (string.IsNullOrWhiteSpace(str) && string.IsNullOrWhiteSpace(other))
            {
                return 0;
            }

            if (string.IsNullOrEmpty(str))
            {
                return 1;
            }
            if (string.IsNullOrEmpty(other))
            {
                return 2;
            }

            //Check if they start with Numbers to compare the numbers.
            var strStartNumber = string.Empty;
            var otherStartNumber = string.Empty;
            var i = 0;
            var j = 0;

            for (i = 0; i < str.Length; i++)
            {
                if (char.IsDigit(str[i]))
                {
                    strStartNumber += str[i];
                }
                else
                {
                    break;
                }
            }

            for (j = 0; j < other.Length; j++)
            {
                if (char.IsDigit(other[j]))
                {
                    otherStartNumber += other[j];
                }
                else
                {
                    break;
                }
            }

            if (!string.IsNullOrEmpty(strStartNumber) && !string.IsNullOrEmpty(otherStartNumber))
            {
                var strNumber = Convert.ToInt32(strStartNumber);
                var otherNumber = Convert.ToInt32(otherStartNumber);

                if (strNumber > otherNumber)
                {
                    return 2;
                }
                if (strNumber < otherNumber)
                {
                    return 1;
                }
            }

            for (; i < str.Length; i++)
            {
                for (; j < other.Length; j++)
                {
                    if (str[i] > other[j])
                    {
                        return 2;
                    }
                    if (str[i] < other[j])
                    {
                        return 1;
                    }
                }
            }

            return 0;
        }

        /// <summary>
        /// Converts a string to a List of Strings using the specified string separator.
        /// For Instance: given the string "fox~frog" and the separator ~
        /// returns the List { fox, frog }
        /// </summary>
        /// <param name="str">String to be converted to a List of Strings.</param>
        /// <param name="separator">Separator.</param>
        /// <returns>List of Strings obtained from the specified string separated
        /// with the specified separator.</returns>
        public static List<string> ToList(this string str, string separator)
        {
            var list = new List<string>();

            if (string.IsNullOrEmpty(separator))
            {
                return list;
            }

            list = str.Split(new string[] { separator }, StringSplitOptions.None).ToList();

            return list;
        }

        /// <summary>
        /// In case the string is a File or Folder Path, this Method goes up n Directories.
        /// </summary>
        /// <param name="str">File or Directory Path.</param>
        /// <param name="n">Number of Directories to go Up.</param>
        /// <returns>The specified Path with the Number of Directories up.</returns>
        public static string NFoldersUp(this string str, int n)
        {
            var result = str;

            for(var i = 0; i < n; i++)
            {
                var lastIndeOf = result.LastIndexOf('\\');

                if(lastIndeOf > 0)
                {
                    result = result.Substring(0, lastIndeOf);
                }
            }

            return result;
        }

		/// <summary>
		/// If the string have only zeros after the decimal point, this Methos returns the Integer Part of the String.
		/// </summary>
		/// <param name="str">String.</param>
		/// <returns>If the string have only zeros after the decimal point, this Methos returns the Integer Part of the String.</returns>
		public static string RemoveTrailingZeros(this string str)
		{
			if(string.IsNullOrEmpty(str))
			{
				return string.Empty;
			}

			var indexOf = str.IndexOf(".");

			if(indexOf > 0)
			{
				var decimals = str.Substring(indexOf + 1);

				if(decimals.Any(x => x != '0'))
				{
					return str;
				}

				//If every decimal Value after the comma is a zero, return the value before the comma.
				return str.Substring(0, indexOf);
			}

			return str;
		}

		/// <summary>
		/// Gets the Total of Decimal Places in the String.
		/// </summary>
		/// <param name="str">String</param>
		/// <returns>Total of Decimal Places in the string.</returns>
		public static int GetDecimalPlaces(this string str)
		{
			var decimalPlaces = 0;

			if (string.IsNullOrEmpty(str))
			{
				return decimalPlaces;
			}

			var indexOf = str.IndexOf(".");

			if(indexOf > 0)
			{
				var decimalPlacesString = str.Substring(indexOf + 1);
				decimalPlaces = decimalPlacesString.Length;
			}

			return decimalPlaces;
		}

        /// <summary>
        /// Gets the Position of the Next corresponding }, ) or ] beginning at the index position.
        /// Example: { Id: 1, NameLanguages: [{Id: 2}]}
        /// Given the index 0, this method will return the position of the last }, which is the corresponding closed }
        /// to the { at the index position.
        /// </summary>
        /// <param name="str">String.</param>
        /// <param name="index">Index to start the search.</param>
        /// <param name="parenthesis">Parenthesis Character. Can be {, ( or [</param>
        /// <returns>Position of the Next corresponding } beginning at the index position.</returns>
        public static int GetClosedParenthesisPosition(this string str, int index = 0, char parenthesis = '{')
        {
            if(string.IsNullOrEmpty(str))
            {
                return -1;
            }

            var openParenthesis = 0;
            var closedParenthesis = 0;

            for(var i = index; i < str.Length; i++)
            {
                if(str[i] == parenthesis)
                {
                    openParenthesis++;
                }
                else if((parenthesis == '{' && str[i] == '}') || (parenthesis == '(' && str[i] == ')') || (parenthesis == '[' && str[i] == ']'))
                {
                    closedParenthesis++;

                    if(openParenthesis == closedParenthesis)
                    {
                        return i;
                    }
                }
            }

            return -1;
        }

        /// <summary>
        /// Gets the Number that ends the string.
        /// For instance: For the Combination 1 string, this Method returns 1.
        /// </summary>
        /// <param name="str">String.</param>
        /// <returns>Greatest Number found at the End of the string.</returns>
        public static int GetLastNumber(this string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return 0;
            }

            var index = string.Empty;
            for (int i = str.Length - 1; i >= 0; i--)
            {
                if (char.IsDigit(str[i]))
                {
                    index += str[i].ToString();
                }
                else
                {
                    var reverseIndexString = index.ReverseString();

                    if (!string.IsNullOrEmpty(reverseIndexString))
                    {
                        var reverseIndex = int.Parse(reverseIndexString);

                        return reverseIndex;
                    }
                }
            }

            return 0;
        }

        /// <summary>
        /// Get a Thickness class from the specified string.
        /// </summary>
        /// <param name="str">String representation of a Thickness.</param>
        /// <returns>Thickness obtained from the string.</returns>
        public static Thickness ToThickness(this string str)
        {
            //Left, Top, Right, Bottom.
            var thickness = new Thickness();

            if (string.IsNullOrEmpty(str))
            {
                return thickness;
            }

            var indexOf = str.IndexOf(',');
            double left = 0;
            double top = 0;
            double right = 0;
            double bottom = 0;

            if (indexOf > 0)
            {
                var leftString = str.Substring(0, indexOf);
                var converted = double.TryParse(leftString, out left);

                if (!converted)
                {
                    return thickness;
                }

                thickness.Left = left;

                var topIndexOf = str.IndexOf(',', indexOf + 1);

                if (topIndexOf > 0)
                {
                    var topString = str.Substring(indexOf + 1, topIndexOf - indexOf - 1);
                    converted = double.TryParse(topString, out top);

                    if (!converted)
                    {
                        return thickness;
                    }

                    thickness.Top = top;

                    var rightIndexOf = str.IndexOf(',', topIndexOf + 1);

                    if (rightIndexOf > 0)
                    {
                        var rightString = str.Substring(topIndexOf + 1, rightIndexOf - topIndexOf - 1);
                        converted = double.TryParse(rightString, out right);

                        if (!converted)
                        {
                            return thickness;
                        }

                        thickness.Right = right;

                        var bottomIndexOf = str.IndexOf(',', rightIndexOf + 1);

                        if (bottomIndexOf < 0)
                        {
                            var bottomString = str.Substring(rightIndexOf + 1);
                            converted = double.TryParse(bottomString, out bottom);

                            if (converted)
                            {
                                thickness.Bottom = bottom;
                            }
                        }
                    }
                }
            }

            return thickness;
        }

        /// <summary>
        /// Converts the specified string to a Brush, if possible.
        /// </summary>
        /// <param name="str">String to be converted to a Brush.</param>
        /// <returns>Brush obtained from the specified string.</returns>
        public static Brush ToBrush(this string str)
        {
            var brush = (SolidColorBrush)new BrushConverter().ConvertFromString(str);

            return brush;
        }

        public static FontWeight ToFontWeight(this string str)
        {
            if (string.IsNullOrEmpty(str))
            {
                return FontWeights.Normal;
            }

            FontWeight fontWt;
            switch (str.ToString())
            {
                case "Bold":
                    fontWt = FontWeights.Bold;
                    break;
                case "ExtraBold":
                    fontWt = FontWeights.ExtraBold;
                    break;
                case "Normal":
                    fontWt = FontWeights.Normal;
                    break;
                case "Light":
                    fontWt = FontWeights.Light;
                    break;
                default:
                    fontWt = FontWeights.Normal;
                    break;
            }

            return fontWt;
        }

        /// <summary>
        /// Replace the extension of the specified string.
        /// </summary>
        /// <param name="str">String</param>
        /// <param name="extension">Extension</param>
        /// <returns>The specified string with its extension replaced with the specified extension.</returns>
        public static string ReplaceExtension(this string str, string extension)
        {
            if(string.IsNullOrEmpty(str))
            {
                return str;
            }

            var lastPointIndexOf = str.LastIndexOf(".");

            if(lastPointIndexOf < 0)
            {
                return str;
            }

            var newString = str.Substring(0, lastPointIndexOf);
            newString += extension;

            return newString;
        }

        /// <summary>
        /// Get bytes of string
        /// </summary>
        /// <param name="str">string</param>
        /// <returns>Bytes of string</returns>
        public static byte[] ToBytes(this string str)
        {
            var bytes = new byte[str.Length * sizeof(char)];
            Buffer.BlockCopy(str.ToCharArray(), 0, bytes, 0, bytes.Length);
            return bytes;
        }

        /// <summary>
        /// Converts a string separated with the specified character separator, into a list of string.
        /// For instance, if the string is a comma separated string, this Method returns a list of strings.
        /// </summary>
        /// <param name="str">String</param>
        /// <param name="separator">Separator character.</param>
        /// <returns>List of strings separated with the specified character separator.</returns>
        public static List<string> SeparatedStringToList(this string str, char separator = ',')
        {
            var list = str.Split(separator).ToList();

            return list;
        }

        /// <summary>
        /// Removes all of the Space characters from the end of a string.
        /// </summary>
        /// <param name="str">String.</param>
        /// <returns>The specified string without any space separator at the end.</returns>
        public static string TrimEndSpaces(this string str)
        {
            return str.TrimEnd(new char[] { ' ', '\t', '\n', '\r' });
        }

        /// <summary>
        /// Removes all of the Space characters from the beginning of a string.
        /// </summary>
        /// <param name="str">String.</param>
        /// <returns>The specified string without any space separator at the beginning.</returns>
        public static string TrimStartSpaces(this string str)
        {
            return str.TrimStart(new char[] { ' ', '\t', '\n', '\r' });
        }

        /// <summary>
        /// Removes all of the Space characters from the beginning and the end of a string.
        /// </summary>
        /// <param name="str">String.</param>
        /// <returns>The specified string without any space separator at the beginning nor in the end.</returns>
        public static string TrimSpaces(this string str)
        {
            var withoutSpaces = str.TrimStartSpaces();
            withoutSpaces = withoutSpaces.TrimEndSpaces();

            return withoutSpaces;
        }

        /// <summary>
        /// Returns the next word in the string from the specified index.
        /// In other words, the substring, of the specified string, without spaces from the specified index.
        /// </summary>
        /// <param name="str">String.</param>
        /// <param name="index">Index to begin searching for the next word.</param>
        /// <returns>Next word (without spaces) in the string from the specified index.
        /// In other words, the substring without spaces from the specified index.</returns>
        public static string NextWord(this string str, ref int index)
        {
            if(string.IsNullOrEmpty(str) || index < 0 || index > str.Length)
            {
                index = -1;
                return string.Empty;
            }

            //Skip all of the Spaces from the index position.
            while (index < str.Length && str[index].IsSeparator())
            {
                index++;
            }

            var startIndex = index;

            //Skip all of the Not Spaces from the index position.
            while (index < str.Length && !str[index].IsSeparator())
            {
                index++;
            }

            if(startIndex >= 0 && startIndex < str.Length && index > 0 && index < str.Length)
            {
                return str.Substring(startIndex, index - startIndex);
            }
            else if(startIndex >= 0 && startIndex < str.Length && index == str.Length)
            {
                return str.Substring(startIndex);
            }

            return string.Empty;
        }

        /// <summary>
        /// Returns the Substring of the string between the specified strings from the specified index.
        /// For instance: Given pp(ghost) and index = 1, leftSide = "(" and rightSide = ")", the result is ghost
        /// </summary>
        /// <param name="str">String.</param>
        /// <param name="index">Index to begin searching for the specified Left and Right sides.</param>
        /// <returns>Substring of the string between the specified strings from the specified index.</returns>
        public static string SubstringBetweenStrings(this string str, ref int index, string leftSide, string rightSide)
        {
            if (string.IsNullOrEmpty(str) || index < 0 || index > str.Length)
            {
                return string.Empty;
            }

            index = str.IndexOf(leftSide, index, StringComparison.InvariantCultureIgnoreCase);

            if(index < 0 || index == str.Length - 1)
            {
                return string.Empty;
            }

            var startIndex = index + 1;

            //If we want to get the string inside parenthesis, we need to search the related closed Parenthesis to the currently opened Parenthesis.
            if (leftSide == "(" && rightSide == ")")
            {
                index = str.GetClosedParenthesisPosition(index, '(');
            }
            else
            {
                index = str.IndexOf(rightSide, index + 1, StringComparison.InvariantCultureIgnoreCase);
            }

            if (startIndex > 0 && startIndex < str.Length && index > 0 && index < str.Length)
            {
                return str.Substring(startIndex, index - startIndex);
            }

            return string.Empty;
        }

        /// <summary>
        /// Checks if the string contains the specified word.
        /// Similar to the Contains Method of the string, but this one only searches the word between character Separators.
        /// For instance, if str = 'ppAndl' and word = 'And'. This Method returns false.
        /// If str = 'pp And l' and word = 'And'. This Method returns true.
        /// </summary>
        /// <param name="str">String</param>
        /// <param name="word">Word to be searched between character separators.</param>
        /// <param name="startIndex">Position to begin the search.</param>
        /// <param name="ignoreCase">Indicates if the case (Upper and Lower) of the characters will be ignored.</param>
        /// <returns>True: The string contains the specified word between character separators.
        /// False: The string does not contains the specified word between character separators.</returns>
        public static int ContainsWord(this string str, string word, int startIndex = 0, bool ignoreCase = true)
        {
            var index = -1;

            if(str == null || word == null || word.Length >= str.Length)
            {
                return index;
            }

            //For with Multiple Variables.
            for (int i = startIndex, j = 0; i < str.Length; i++)
            {
                if(j < word.Length && str[i].EqualsCase(word[j], ignoreCase))
                {
                    //Search for a Space Separator before the first character.
                    if(j == 0 && i > 0)
                    {
                        if(!str[i - 1].IsSeparator())
                        {
                            continue;
                        }
                    }

                    j++;
                    continue;
                }
                else if(j >= word.Length && str[i].IsSeparator())
                {
                    return i - word.Length;
                }
                else if(j >= word.Length || (j < word.Length && !str[i].EqualsCase(word[j], ignoreCase)))
                {
                    j = 0;
                }
            }

            return -1;
        }
    }
}
